[{"title":"一日双城、一日双塔挑战记录","url":"%2F2019%2F05%2F20%2Fcycle%2F","content":"1. [双城](https://connect.garmin.com/modern/activity/1009707790)\n2. [双塔](https://connect.garmin.com/modern/activity/1070451224)\n\n","tags":["Taiwan"],"categories":["oneDayChallenge"]},{"title":"ps 人像懒人包","url":"%2F2019%2F05%2F01%2Fps%2F","content":"\n1. 黑眼圈：画笔工具 ➡ 透明度 30%（10-30%） ➡ Opt + 鼠标左键吸正常肤色 ➡ 层叠覆盖，不要涂抹\n\n2. 去痘：两种方式\n    - 修补工具 ➡ 鼠标勾勒轮廓 ➡ 移动至适用部位即可\n    - 图章工具 ➡ 移动至光滑皮肤 Opt + 鼠标左键选择当前作为印章样式 ➡ 在痘上单机左键即可修复 \n\n<!-- more -->\n\n3. 磨皮：\n\n- 通道 ➡ 复制蓝色通道\n- 滤镜 ➡ 其他 ➡ 高反差保留 ➡ 半径 8 像素\n- 画笔 ➡ 前景色 #9f9f9f，硬度100%，透明度100%，流量100% 画出人像的眼睛和嘴巴\n- 图像 ➡ 计算 ➡ 混合模式：强光 ➡ 确定后得到 Alpha 1，重复至得到 Alpha 3\n- Cmd + 点击 Alpha 3 的缩略图（选中光滑部分） ➡ Cmd + Shift + i （反选）\n- 添加曲线，在曲线从左到右近 4/5 处往上拖动（已基本光滑）\n- Cmd + Opt + Shift + e 得到合并图层\n- 用修复工具去痘\n- 图层 ➡ 新建 ➡ 颜色：灰色；模式：柔光；钩上填充柔光中性色（50%灰）\n- 画笔 ➡ 选择合适的颜色去涂五官 ➡ 不透明度：35%，硬度：0\n- 调整 ➡ 色彩平衡（随意）\n- Cmd + Opt + Shift + e 得到最终合并图层\n","tags":["Photoshop"],"categories":["Photoshop"]},{"title":".gitignore 用法、模版与自动生成","url":"%2F2019%2F02%2F26%2Fgitignore%2F","content":"### 使用方法\n\n- 在根目录创建 .gitignore\n- 文件 .gitignore 的格式规范如下：\n  - 所有空行或以 # 开头的\b行（注释）都会被Git忽略\n  - 可以使用标准 glob 模式（shell 使用的简化正则表达式）匹配\n  - 如要忽略目录则在后面添加\b反斜杠 /\n  - 反向忽略可在模式前加惊叹号 ! 取反\n\n  示例如下：\n\n  ```\n  *.json           # 忽略整个目录下所有以 .json 结尾的文件\n  !jsconfig.json   # 但jsconfig.json除外\n  /local           # 忽略主目录下的local文件（或文件夹）\n  library/         # 忽略library文件夹\n  assets/*.meta    # 忽略assets\b直属子目录下的所有 .meta 文件 \n  ```\n---\n### 自动生成 .gitignore \n\n访问[gitignore.io](https://gitignore.io/)\n\n---\n### github 团队提供的各种语言的 .gitignore 模版\n\n[node](https://github.com/github/gitignore/blob/master/Node.gitignore) 如下：\n\n```\n# Logs\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\n\n# Runtime data\npids\n*.pid\n*.seed\n*.pid.lock\n\n# Directory for instrumented libs generated by jscoverage/JSCover\nlib-cov\n\n# Coverage directory used by tools like istanbul\ncoverage\n\n# nyc test coverage\n.nyc_output\n\n# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)\n.grunt\n\n# Bower dependency directory (https://bower.io/)\nbower_components\n\n# node-waf configuration\n.lock-wscript\n\n# Compiled binary addons (https://nodejs.org/api/addons.html)\nbuild/Release\n\n# Dependency directories\nnode_modules/\njspm_packages/\n\n# TypeScript v1 declaration files\ntypings/\n\n# Optional npm cache directory\n.npm\n\n# Optional eslint cache\n.eslintcache\n\n# Optional REPL history\n.node_repl_history\n\n# Output of 'npm pack'\n*.tgz\n\n# Yarn Integrity file\n.yarn-integrity\n\n# dotenv environment variables file\n.env\n.env.test\n\n# parcel-bundler cache (https://parceljs.org/)\n.cache\n\n# next.js build output\n.next\n\n# nuxt.js build output\n.nuxt\n\n# vuepress build output\n.vuepress/dist\n\n# Serverless directories\n.serverless/\n\n# FuseBox cache\n.fusebox/\n\n# DynamoDB Local files\n.dynamodb/\n```\n","tags":["gitignore"],"categories":["programing"]},{"title":"Docker 注意事项","url":"%2F2019%2F02%2F24%2Fdocker-tips%2F","content":"\n1. 在 docker 容器内使用 vim 时提示“vi: command not found”，需要先在容器里安装 vim，即运行`apt-get update && apt-get -yq install vim` 即可\n\n2. `docker run` 的参数 `-p` 指**主机（宿主）端口：容器端口**\n\n3. docker 内运行 node，容器的端口和主机的端口必须全部与容器内运行的 node 端口一致\n","tags":["docker"],"categories":["programing"]},{"title":"VPS 服务器 ssr 基础操作简记","url":"%2F2019%2F02%2F07%2Fvps%2F","content":"\n*VPS \b被封几率太高，简列基本操作步骤方便使用*\n\n1. 服务器端一步搭建\n\n    参考[自建vps服务器教程](https://github.com/Alvin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B)\n\n    ```bash\n    # 2018.11.20 更新\n    wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh && chmod +x ssr.sh && bash ssr.sh\n    ```\n\n2. 服务端管理 \bssr（进入安装 ssr 目录后执行）：`bash ssr.sh` 或 `./ssr`\n\n3. 免费 ssr 账号或浏览器翻墙\n\n    [GitHub](https://github.com/Alvin9999/new-pac/wiki/ss%E5%85%8D%E8%B4%B9%E8%B4%A6%E5%8F%B7)\n    [Gitlab(备用)](https://gitlab.com/Alvin9999/free/wikis/ss%E5%85%8D%E8%B4%B9%E8%B4%A6%E5%8F%B7)","tags":["ssr"],"categories":["fly"]},{"title":"Node 笔记","url":"%2F2019%2F01%2F16%2Fnode%2F","content":"\n1. Node 使用了与 Web Workers 相同的模式解决线程中的问题，child_process 是基础 API，cluster 模块是更深层次应用。\n2. 事件循环、观察者、请求对象、I/O 线程池共同构成 Node 异步 I/O模型的基本要素\n3. Node 中除了 JavaScript 是单线程， Node 自身是多线程，只是 I/O 线程使用的 CPU 较少\n4. Node 中除用户代码不不可并行执行，所有的 I/O（磁盘 I/O 和网络 I/O 等）都可以并行\n\n<!-- more -->\n\n5. 一个\b程序如果大部分时间进行计算、逻辑判断，称为 *CPU 密集*（压缩、解压、加密、解密），如果\b多进行存取、网络操作，称为 *I/O 密集*（文件操作、网络操作、数据库）\n6. 函数式编程包括高阶函数（函数作为参数或返回值）和偏函数用法（创建一个*调用另外一个参数或变量已经预置的函数*的函数）\n7. 异步编程方案：\n- 事件监听模式，又称发布/订阅模式\n  \n  具有 addListener/on()、once()、removeListener()、removeAllListeners()、emit()等\n- Promise/Deferred 模式\n\n  包括 Promises/A、Promises/B、Promises/D。\n\n  一个 Promise \b对象具备 then() 方法，then() 定义为 `then(fulfilledHandler, errorHandler, progressHandler)`，接受完成态、错误态的回调，可选地支持 progress 事件回调。then() 只接受 function 对象，其余对象忽略，返回 Promise 对象，\b以实现链式调用。\n\n- 流程控制库\n\n  - 尾触发与 Next\n\n    需要手工调用才能持续执行后续调用的方法称为尾触发，常见的关键词是 next。多用于 Connect 中间件，将复杂的处理逻辑拆解为单一的处理单元逐层处理请求对象和响应对象。\n  \n  - async\n\n    - 异步的串行执行\n    - 异步的并行执行（parallel()）\n    - 异步调用的依赖处理（waterfall()）\n    - 自动依赖处理（auto()）\n  \n  - Step\n\n    `Step(task1, task2, task3)`\n\n  - wind\n\n- 异步并发控制\n\n  - bagpipe\n  - async 的 parallelLimit()\n\n8. 进程与线程\n\n- 进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。\n\n- 线程是进程内一个相对独立、可调度的执行单元，与同属一个进程的线程共享进程的资源。多线程指启动一个进程，在一个进程内启动多个线程，这样多个线程也可以一块执行多个任务\n\n9. require 特性：\n\n- module 被加载时执行，加载后缓存\n- 一旦出现某个模块被循环加载，就只输出已经执行的部分，未执行部分不输出\n\n10. commonJS 默认将 exports 设置为 module.exports，所以只能给 exports \b添加属性，不能修改指向（eg: exports = ...)，修改后值为 undefined，\bcommonJS 模块对外输出永远是 module.exports。如想修改指向用 `module.exports = ...` 即可\n\n11. path\n\n- “\\_\\_dirname”、“\\_\\_filename” 总是返回文件的绝对路径\n- “process.cwd()” 总是返回执行 node 命令所在文件夹\n- “./” 在 require 方法中总是相对当前文件所在文件夹（绝对路径）；在其他地方时则与 “process.cwd()” 相同\n\n12. Buffer 的实例 buf.length 表示申请的空间，而不是内容\n\n    ```js\n    const buf = Buffer.from('this is a test!')\n    console.log(buf.length) // 15（字节） 一个中文三个字节\n    const buf2 = Buffer.allocUnsafe(10) // 或 const buf2 = Buffer.alloc(10)\n    buf2[0] = 2\n    console.log(buf2.length) // 10\n    ```\n\n13. \n","tags":["node"],"categories":["programing"]},{"title":"Markdown Cheat Sheet","url":"%2F2019%2F01%2F03%2Fmarkdown%2F","content":"\n| Element | Markdown Syntax |\n| :--- | :--- |\n| 标题 | # H1<br> ## H2 <br> ### H3 |\n| 粗体 | \\*\\*bold text** |\n| 斜体 | \\*italicized text* |\n| 引用 | \\> blockquote |\n| 有序列表 | 1. First item <br> 2. Second item <br> 3. Third item |\n| 无序列表 | - First item <br> - Second item <br> - Third item |\n| 代码 | \\`code` |\n| 分割线 | \\-\\-\\- |\n| 链接 | \\[title\\](https://www.example.com) |\n| 图片 | \\!\\[alt rext](image.jpg) |\n| 表格 | &vert; Syntax &vert; Description &vert;<br> &vert; \\-\\-\\-\\-\\-\\-\\-\\-\\- &vert; \\-\\-\\-\\-\\-\\-\\-\\-\\- &vert;<br> &vert; Header &vert; Title &vert;<br> &vert; Paragraph &vert; Text &vert; |\n| 分栏代码块 | \\`\\`\\`<br>{<br>\"firstName\": John\",<br>\"lastName\": \"Smith\",<br>\"age\": 25<br>}<br>\\`\\`\\` |\n| 注释 | Here's a sentence with a footnote. [^1]<br><br>[^1]: This is the footnote. |\n| 删除线 | \\~~The world is flat.~~ |\n| 待办列表 | - [x] Write the press release <br> - [ ] Update the website |\n\n<!-- more -->\n\n---\n\n#### 注意：\n- 表格内换行在语句末尾加`<br>`即可\n- 输入以下这些符号\b，需要在符号前加“\\”进行转义：\n  ```\n  \\\n  `\n  *\n  _\n  {}\n  []\n  ()\n  #\n  +\n  -\n  .\n  !\n  ```\n- 输入“|”，“\\”转义无效，需要使用\b字符实体，以下方法任选其一：\n  ```\n  &verbar; \n  &vert; \n  &VerticalLine; \n  &#x0007C; \n  &#124;\n  ```\n","tags":["markdown"],"categories":["programing"]},{"title":"书籍资源整理","url":"%2F2019%2F01%2F03%2Fbooks%2F","content":"\n*整理部分质量较高的书籍资源，持续更新*\n## 技术类\n\n1. Node.js.8.the.Right.Way.2018版  [下载地址](https://pan.baidu.com/s/1Z43JvxwRq5skV9V-GqVP4Q)  密码:k6af\b\n\n2. 深入浅出Node.js  [下载地址](https://pan.baidu.com/s/1NkwWzwodBbJHtyC9XoC0LA)  密码:4i3t\n\n3. pro git  [下载地址](https://pan.baidu.com/s/1kAuzbyFf0-4Pi3cqvDRg6Q)  密码:d06p\n\n4. Learning the bash Shell, 2nd Ed - 2Nd Edition  [下载地址](https://pan.baidu.com/s/1DYmiS7QkhelM7Wano9TeyQ)  密码:98o3\n\n5. 代码大全2  [下载地址](https://pan.baidu.com/s/1qxTUpFCTo5wl-mvw6fAUjQ)  密码:64he\n\n<!-- more -->\n\n## 杂书\n\n1. 商务印书馆A类哲学本 153本  [下载地址](https://pan.baidu.com/s/1EEy3IQCBzlTbImi5GmHUsA)  密码:kvmx\n\n2. 红太阳是怎样升起的：延安整风运动的来龙去脉  [下载地址](https://u17766478.ctfile.com/fs/17766478-328721125)\n\n3. 加缪全集（6册） [下载地址](https://pan.baidu.com/s/1YHhjheodUDHmIqjfdiaoRw)  密码:sn31\n","tags":["books"],"categories":["resources"]},{"title":"Linux 常用命令","url":"%2F2018%2F12%2F14%2FLinux-kb%2F","content":"\n1. 进程\n  - 查看占用某端口的程序： `lsof -i:xxxx`\n  - 结束进程： `kill [PID]`\n  - 查看某端口进程： `netstat -ant | grep [port]`\n  - 查看某端口进程（包括pid）： `netstat -antp | grep [port]` （加p即可）\n  - 终止当前进程： `control-C`\n\n<!-- more -->\n\n2. 文件\n  - 显示当前目录的内容： `ls`\n  - 查看隐藏内容： `ls -a`\n  - 查看较多信息： `ll`（`ls -l` 的缩写）\n  - 显示路径的权限： `namei -om /[path]`\n  - 查看文件运行路径： `which [filename]`\n  - 查看文件安装路径： `whereis [filename]`\n  - 执行脚本： `source [filename]` 或 `./[filename]`\n  - 将文件变为可执行文件： `chmod +x [file-name]`\n  - 清除到开头： `command-K`\n  - 按照文件名查找： `find -[file-name]` （配合 xargs 能执行基本所以有的文件操作）\n  - 移动/重命名某个文件或文件夹： `mv [file/folder]`\n  - 查看软件\b版本： `[software-name] -v` 或 `[software-name] --version`\n\n3. 网络\n  - 查看IP： `ifconfig` （在 en0 的 inet）\n\n4. 服务器\n  - ssh 免密登录服务器： `ssh-copy-id -p [port] [user]@[host]`\n  - ssh 指定某个公钥免密码登陆服务器 \b`ssh-copy-id -i [filename] -p [port] [user]@[host]`）\n  - 从远处复制文件到本地： `scp (-P [port]) [remote_username]@[remote_ip]:[remote-file] [local_path]`\n  - 从远处复制文件夹到本地： （加一个参数r即可）`scp -r (-P [port]) [remote_username]@[remote_ip]:[remote-folder] [local_path]`\n  - 从本地上传文件到远处： `scp [local_file] (-P [port]) [remote_user]@[remote_ip]:[remote_path]`\n  - 从本地上传文件夹到远处： `scp -r [local_folder] (-P [port]) [remote_user]@[remote_ip]:[remote_path]`\n","tags":["Linux"],"categories":["keyboard"]},{"title":"VPS 服务端 CentOS + Nginx 结合本地 Hexo + Rsync 部署技术博客到独立域名的完整要点总结","url":"%2F2018%2F12%2F10%2Fhexo%2F","content":"\n### 1. 既定为已购入 vps 和域名，这里只简述流程\n\n在[bandwagon](https://bwh1.net/) 等上购买 vps，在 Kivi panel \b设置好 vps 的\b配置，我安装的是 CentOS，在本地通过 ssh 连接能够成功连接到 \bvps 即可。在 [namesilo](https://www.namesilo.com/index.php) 等\b购买域名，根据需求设置域名的 DNS 解析，可以设置多个映射，也可以添加 email 等。这里需要添加刚部署好的\b vps 主机地址。\n\n<!-- more -->\n\n因为购买的是国外 vps，所以需要将\b此 vps 解析才能在国内正常访问（如购买国内 vps 无需进行下步操作）。在 [dnspod](https://www.dnspod.cn/) 注册账户（一般如果只要支持博客免费账户即可），添加 vps 主机地址进行域名解析，并且这个网站提供有免费监控，\b根据需求设置即可。\n\n完成这些步骤后，\b测试若在 VPS 上编辑内容，直接打开域名可查看这些内容即为成功。\n\n### 2. 在本地安装 Node 和 Hexo，可成功访问到本地的临时 \bHexo 页面即可\n\n### 3. 服务端设置反向代理至独立域名\n\n在 Linux 上安装 EPEL 和 Nginx：\n```bash\n$ sudo yum install epel-release\n$ sudo yum install nginx\n```\n\n安装过程中可能会遇到的问题在另一篇博客中列举，此处不赘述。\n\n安装完成后启动 Nginx：`sudo systemctl start nginx`，此时访问 \bVPS 主机地址（不用写端口号）可看到 Nginx 的欢迎页。\n\n下面进行 Nginx 的配置：\n- \b新建文件夹，目的是存放\b这个博客页面需要的文件，这个文件夹\b地址可以随意设置，只要所有的配置文件注意地址统一即可，这里将文件存放在`/var/www/blog`\n\t```bash\n\t$ mkdir -p /var/www/blog\n\t```\n- 在\b这个文件夹内新建`index.html`，用于测试，内容如下：\n  ```html\n  <html>\n    <head>\n      <title>My Blog</title>\n    </head>\n    <body>\n      <h1>The Blog server block is successful</h1>\n    </body>\n  </html>\n  ```\n- 设置反向代理，即 Nginx 的配置文件\n\n  在 `/etc/nginx/conf.d` 新建配置文件 `blog.conf`（什么名字都可以）\n\n  ```nginx\n  server {\n    listen 80;\n    listen [::]:80;\n    root /var/www/blog;\n    index index.html index.htm index.nginx-debian.html;\n    server_name shifei.online www.shifei.online;\n    location / {\n      try_files $uri $uri/ =404;\n    }\n  }\n  ```\n- 重启 Nginx，使新设定生效（不重启则无效）\n\n  ```bash\n  $ sudo systemctl restart nginx\n  ```\n\n  打开域名网址，如看到之前写的 html 页面则配置成功。\n\n### 4. 将本地 Hexo 部署到域名\n\n在两端分别安装 rsync， 服务端执行 `yum install rsync`，本地执行`npm install hexo-deployer-rsync --save`。\n\n在本地的 Hexo 整体配置文件 `_config.yml` 中修改 ‘deploy’ 的设置，可参考如下配置：\n```yml\ndeploy: \n  type: rsync\n  host: 144.296.129.92  # VPS 地址\n  user: root  # VPS 登陆用户名\n  root: /var/www/blog  # 同步更新的所有页面存放文件夹\n  port: 640  # VPS 端口号\n  delete: true  # 删除远程主机上的旧文件\n  verbose: true  # 显示调试信息\n  ignore_errors: false  # 不忽略错误（前五项必填）\n```\n\n部署完成，以后每次本地更新完博客内容后，执行 `hexo g -d` 即可推送至服务器，在服务端可以通过 `ssh-copy-id` 获得本地这台机器的\b证书，可以免密\b登陆（以免每次更新都要输入密码）。\n","tags":["nginx"],"categories":["programing"]},{"title":"centos 安装 nginx 时提示‘No package nginx available‘或’Nothing to do‘","url":"%2F2018%2F12%2F10%2Fnginx%E9%94%99%E8%AF%AF%2F","content":"\n出现该问题的原因是本地 yum 源中没有 nginx，需要创建一个 ‘/etc/yum.repos.d/nginx.repo’ 文件，新增一个 yum 源\n\n<!-- more -->\n\n```bash\n[root@144 ~]# vim /etc/yum.repos.d/nginx.repo\n#在文件中写入以下内容：\n[nginx]\nname=nginx repo\nbaseurl=http://nginx.org/packages/centos/$releasever/$basearch/\ngpgcheck=0\nenabled=1\n```\n","tags":["nginx"],"categories":["programing"]},{"title":"台湾九合一选举之思","url":"%2F2018%2F12%2F10%2Ftaiwan%2F","content":"\n### 台湾九合一选举之思\n\n从半个多月前选举直播开始关注这次选举，逐渐对台湾的选举制度和一些政客有一些粗浅的了解，就算不能做到完全中立，还是尽量保持客观的角度谈论我的看法，并由浅及深，寻找问题的根源在何处。\n\n<!-- more -->\n凭良心讲，这几天一直在疑惑到底为什么竟有半数的人不会支持柯文哲这种人，踏实做事，不搞政治，不求名利，台北市支持率反而是台湾垫底，仅仅是因为触碰了某些人的利益么？难道说他的所作所为老百姓都不是有目共睹的吗？宁愿选择空口白话的政治家上台都不要这样24*7来为台湾未来着想的人吗？\n\n今天下午蔡柯会，看完之后这个苦恼真的让我烦到顶峰，心里烦得很，什么都做不下去，随意翻着一些早期的视频，还是烦躁，出去篼个风，冷风一吹，一个非常大胆的想法迸发出来，并且按着这样推理下去，似乎所有问题都迎刃而解了，不过这些问题更深层次的根源让人想了越发沉重。\n\n既然选举时会有很多出格和疯狂的举动，如果说所有的黑料全是假的呢？14年就已经见识过了，没有办法，团队从各个角度来讲实力都相差悬殊，今年更甚，网络这招已经不管用了，顺便说一句奉劝想找网红各位用多了就烂了；其次，为了选举，政客真的没有底线，是完全没有底线的，从柯p这边来看，起码没有故意抹黑，人心险恶，可以用更险恶去打败，但有些人选择不去做。这里我并不是一味的脑残粉一样去盲目的喜欢或相信，有一件事，我可以说是绝无可能的，就是柯文哲和大陆联合活摘器官这件事。\n\n说到活摘，真的笑出声了，我真的感谢台湾的媒体这么高估内地的医院，如此的有人性。不是说台湾的媒体无知，因为整体的舆论氛围相比大陆来讲是很开放，没有太多的是非观念，什么事情张口就来，没有过调查，也常被当作利用工具，不会像大陆一般的限制多多，这个不能讲那个不许讲，但是我头一次发现什么都能讲也不见得都是好事。\n\n关于内地的活摘，我研究了很长时间，不是光凭这边或者那边的几个漏洞百出的视频或者文章就断定出的，到现在，我差不多可以下一个结论：活摘在大陆存在（过）的可能性是很大的。可能早起或许是跟轮子有关系，后来可能更多是死囚吧，但是希望所有人能了解，到目前，大陆同胞的就医质量相对还是比较低的，当然了我说的是平民老百姓，有钱人另当别论。多少人就因为交不起那几百几千的急诊费用死在医院的？又多了多少起伤医暴力事件？看病需要多少红包才能治好？当然我也不是说医生不负责任，只是现在社会发展种种原因导致这种现状，医生压力过不得不如此，为避免长篇累牍这里暂且不论。总而言之，内地的普通市民在医院里的人权是很低的，我们对医生也没有什么期待。对于法轮功或者死囚就更不必说了，没有人会在乎的，至于所谓的使用叶克膜活摘器官，更是无稽之谈。首先，没有人会在乎他们的生命、死活，这些人，说实话本来也是命不久矣（不是该死，而是分析当时的情况得出结论，毕竟没有人会蠢到把这些人活着放出去散布传言不是？）；其次，难道你们觉得会有医院和医生肯为将死之人使用这么昂贵的技术把所有的钱打水漂而宁可不去救治其他的能支付医疗费用的病人？他们舍得的话也不会枉死那么多的穷人。我明明知道是假的，但是一厢情愿希望是真的，因为我也想要有人情味的医生，和一个真正和谐的社会，而不是一个被和谐的社会。\n\n多党制，开放的社会舆论，初来乍到时确实觉得新鲜、渴望，可是这种开放衍生出的是什么？不顾是非，颠倒黑白，毫无原则，毫无底线，随意操弄，我突然发现，竟然真的一个地方会长期的做到这样，台湾，而这么多年过去，人们似乎也并无意识，呵，或许我也是五十步笑百步罢了。\n\n每一种行为、每一种选择都各有利弊，总在两个极端之间寻找平衡。当这个平衡慢慢倾斜，滑向任意一边，终究会引起反抗和改革。不过台湾很幸运，这么早就开始了，大陆还有的徘徊吧。我想今天心情烦闷的原因大概是我发现，柯p竞选2020的前景更偏于暗淡，不是消沉，而是各种现实显示的，原因上文已经提过不再赘述。这种人选不上总统，是注定的，改革是需要时间的，群体的思想转变需要很长时间。反过来讲，内地不是也没有这种人，一是不会或不许宣传，二是这些人多半在某处就被打压，要么无甚官职，要么尸骨无存，想要突围，这条路比台北要难得多得多了。台湾或许几代人，那么大陆可能要几十代人才能得见。\n","tags":["Taiwan"],"categories":["thoughts"]},{"title":"VS Code 常用快捷键","url":"%2F2018%2F12%2F02%2Fvs-kb%2F","content":"\n1. 显示/隐藏 problem panel：Shift + Cmd + M\n2. 显示/隐藏 panel： Cmd + J\n2. 显示/隐藏 side bar： Cmd + B\n3. 显示/隐藏 activity bar（最左）（自定义）：Cmd + K Cmd + H","tags":["VS Code"],"categories":["keyboard"]},{"title":"代码规范","url":"%2F2018%2F10%2F19%2Fstandard%2F","content":"\n### 空格\n\n1. 函数签名部分有空格，函数名与小括号之间不需要空格，如下\n\n  ```js\n  const x = function () {};\n  const y = function a() {};\n  ```\n\n<!-- more -->\n\n2. 在 if、while 等控制语句后，即小括号前需要空格，参数列表和函数名之间不空格，如下所示：\n\n  ```js\n  if (isJedi) {\n    fight();\n  }\n\n  function fight() {\n    console.log('Swooosh!');\n  }\n  ```\n\n3. 小括号内不加空格：\n\n  ```js\n  function bar(foo) {\n    return foo;\n  }\n\n  if (foo) {\n    console.log(foo);\n  }\n  ```\n\n4. 方括号内不加空格，逗号分隔符后加空格，如下：\n\n  ```js\n  const foo = [1, 2, 3];\n  console.log(foo[0]);\n  ```\n\n5. 大括号内外都加空格：\n\n  ```js\n  const foo = { clark: 'kent' };\n  ```\n\n6. 对象的字面量属性，即 key-value 之间需要空格，如下所示：\n\n  ```js\n  var obj = { \"foo\": 42 };\n  ```\n\n**总结**\n\n- 需要空格：function、if 与小括号之间、大括号内外、key-value、行末\n- 不需要空格：函数名、参数与小括号之间、小括号内、方括号内、调用函数时\n","tags":["standard"],"categories":["programing"]},{"title":"Git 总结","url":"%2F2018%2F10%2F18%2FGit%E6%80%BB%E7%BB%93%2F","content":"\n### 常用命令\n\n\n---\n\n### 错误提示解决方案\n\n1. 提示`warning: CRLF will be replaced by LF in XXX . The file will have its original line endings in your working directory.`\n\n    **解决方法** `git config core.autocrlf false `（关闭自动转换）\n\n<!-- more -->\n\n2. 提示如下\n\n\t```bash\n\tfatal: 'origin' does not appear to be a git repository\n\tfatal: Could not read from remote repository\n\n\t```\n  \n**解决方法** `git remote add origin <url>`\n\n3. ‘push’ 时遇到版本问题（如远程主机的版本比本地的新，又不想使用‘pull’做合并再推送时），可使用强制推送：`git push -f origin master`，该命令会覆盖远程主机版本，慎用。\n\n4. Git 删除远程文件或文件夹，并且保留本地文件\n\n\t```bash\n\tgit rm --cached filename/-r directory\n\tgit commit -m \"remove file/directory\"\n\tgit push\n\t```\n\n---\n\n### 生僻用法\n\n1. 使用 `git add [filename] -e` 可以查看并修改过的内容，在使用本代码后会进入 vim 模式并显示 diff 信息，例如：\n\t```bash\n\tdiff --git a/feature.rb b/feature.rb   # 比较的本件, Git 自动命名为a、b\n\tindex 1a271e9..4a80dda 100644  # 元数据，1a271e9 和 4a80dda 代表两个文件的哈希值，最后的数字代表文件模式（100644 表示普通文件，100755 表示可执行文件， 120000 表示符号链接）\n\t--- a/feature.rb  # 文件标记\n\t+++ b/feature.rb  # 同上\n\t@@ -1 +1,3 @@  # 从本行起至末尾为一个改动区块，本行为区块头，来自文件 a 的标记为‘-’，来自文件 b 的标记为‘+’，意思是从第一行开始的3行代码\n\tthis is the class of my feature  # 上下文环境\n\t+This change belongs to the first feature  # 改动，‘+’表示 b 新增加的内容\n\t+This change belongs to the second feature  # 同上\n\t```\n","tags":["Git"],"categories":["programing"]},{"title":"Nginx 简介及使用","url":"%2F2018%2F07%2F05%2Fnginx%2F","content":"\n## LNMP\n\n**1.简介**\n\n工作中常会需要多个容器相互配合来完成某项任务，如实现一个web项目，需要web服务器、数据库服务器、负载均衡等，使用docker逐个构建则任务繁重。Compose是docker官方的开源项目，定义和运行多个docker容器的应用，能实现对docker容器集群的快速编排，定义一组相关联的容器为一个项目。\n\n<!-- more -->\n\nLNMP（LEMP）即Linux + Nginx + MySQL + PHP 的服务器架构，与LAMP相比，Nginx性能更强，资源占用少，效率更高。\n\nLNMP的实现原理：\n\n - 浏览器发送http请求到服务器（Nginx），服务器响应并处理web请求，将静态资源保存在服务器\n - PHP脚本通过接口传输协议（网关协议）php-fcgi传输给php-fpm（进程管理程序）,PHP-FPM不做处理，然后PHP-FPM调用PHP解析器进程，PHP解析器解析php脚本信息。PHP解析器进程可以启动多个，进行并发执行。\n - 将解析后的脚本返回到PHP-FPM，PHP-FPM再通过fast-cgi的形式将脚本信息传送给Nginx。\n - 服务器再通过Http response的形式传送给浏览器。浏览器再进行解析与渲染然后进行呈现。\n\n![流程图](https://github.com/bravist/lnmp-docker/raw/master/docker.png)\n\n**2.使用**\n\n- 环境准备\ndocker\n- docker-compose的简单配置\n在目标文件夹内创建docker-compose.yml\n\n```python\n# docker-compose.yml\nversion: '3'\n\nservices:\n    # Web server\n    Nginx:\n        image: nginx:latest\n        ports:\n            - 23333:80\n        depends_on:\n            - php\n        volumes:\n            - ./images/nginx/config:/etc/nginx/conf.d:ro\n\n    # PHP\n    php:\n        image: php:latest\n        build:\n            # Dockerfile所在的文件目录和文件名\n            context: ./images/php\n            dockerfile: Dockerfile\n        volumes:\n            - ./apps:/mnt/apps\n\n    # database\n    MySQL:\n        image: mysql:latest\n        ports:\n\t\t    - 3306:3306\n        # 配置环境变量\n        environment:\n            RACK_ENV: development\n            MYSQL_ROOT_PASSWORD: 'root'\n            MYSQL_USER: 'root'\n            MYSQL_PASSWORD: 'passwd'\n        volumes:\n            - ./database:/var/lib/mysql\n\n    # 便于命令工具操作项目文件\n    console:\n\t\tbuild:\n\t\t    context: ~/workspace/lnmp/images/console\n\t\t    dockerfile: /Users/eric/workspace/lnmp/images/php/Dockerfile\n\t\ttty: true\n```\n\n在docker-compose.yml中改变Nginx映射的配置目录，在新目录下增加配置default.conf\n\n```python\n# default.conf\n# 虚拟主机配置\nserver{\n    listen 80;\n    server_name localhost;# 域名\n    root /mnt/apps;# 站点目录\n    index index.php index.html index.htm;\n    location / {\n        index index.php index.html;\n        try_files $uri $uri/ /index.php?$query_string;\n    }\n\n    location ~ \\.php$ {\n\t    fastcgi_pass php:9000;\n        fastcgi_index index.php;\n        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n        include fastcgi_params;\n    }\n}\n```\n添加Dockerfile，代码如下：\n\n```python\n# Dockerfile\nFROM php:7.2-fpm\n\nRUN apt-get update && apt-get install -y apt-transport-https\n\nRUN apt-get update && apt-get install -y pdo pdo_mysql pdo_pgsql \\\n    && docker-php-ext-install pdo \\\n    && docker-php-ext-install pdo_mysql \\\n    && docker-php-ext-install pdo_pgsql\n\nRUN apt-get update && apt-get install -y \\\n        libfreetype6-dev \\\n        libjpeg62-turbo-dev \\\n        libmcrypt-dev \\\n        libpng-dev \\\n    && docker-php-ext-install -j$(nproc) iconv mcrypt \\\n    && docker-php-ext-configure gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ \\\n    && docker-php-ext-install -j$(nproc) gd\n\n# 安装 composer\nRUN curl -o composer.phar https://getcomposer.org/download/1.4.1/composer.phar \\\n    && chmod +x composer.phar\n```\n\n**3.安装及设置**\n\n- 创建容器\n  在Dockerfile的目录中运行命令`docker-compose up --build -d`,运行后docker会有四个容器运行。原目录下有三个子目录：apps用于存放项目文件，database是mySQL的数据库映射，images存放Dockerfile等配置文件。\n\n- 测试\n\n - Nginx与PHP\n\n     可在项目中的apps目录下添加test.php（如下）测试环境，容器运行后打开127.0.0.1:23333/test.php，如成功则显示当前安装的PHP版本和所有配置信息。\n   \n - PHP与mySQL\n \n     在同上位置添加test-mysql.php，内容如下：\n\n```php\n//test.php\n<?php\n    phpinfo();\n?>\n```\n\n```php\n//test-mysql.php\n<?php\n$dbms='mysql';   //数据库类型\n$host='localhost'; //数据库主机名\n$dbName='mysql';    //使用的数据库\n$user='sf';      //数据库连接用户名\n$pass='passwd';          //对应的密码\n$dsn=\"$dbms:host=$host;dbname=$dbName\";\n\ntry {\n    $dbh = new PDO($dsn, $user, $pass); //初始化一个PDO对象\n    echo \"连接成功<br/>\";\n    $dbh = null;\n} catch (PDOException $e) {\n    die (\"Error!: \" . $e->getMessage() . \"<br/>\");\n}\n// 如需长链接如下\n// $db = new PDO($dsn, $user, $pass, array(PDO::ATTR_PERSISTENT => true));\n\n?>\n```\n\n- 删除容器\n   无需该环境时即可销毁容器，运行`docker-compose down`。\n\n**4.注意（坑）**\n\n- yaml不允许tab替换空格\n- dockerfile构建的路径为绝对路径\n- php5以上版本已经废除mysql_connect()方法\n\n\n\n## 使用Nginx\n\n**1.简介**\n\nNginx是异步框架的Web服务器，同时可用作反向代理、负载平衡器和HTTP缓存。\n\nNginx是面向性能设计的HTTP服务器，相较于Apache、lighttpd具有占有内存少，稳定性高等优势。而且在实际工作中，Nginx可以支持二万到四万个并行链接。\n\n**2.docker与Nginx的配置**\n\n - 安装：通过`docker run -p 127.0.0.1:3423:80 --name mynginx -d nginx`下载并运行Nginx容器，如成功安装运行，打开127.0.0.1:3423即可看见Nginx欢迎页。\n - 停止：`docker container stop mynginx`，在安装时设置了删除参数，容器终止后容器文件会自动删除\n - 修改映射网页目录：新建并如下目录，新建index.html，将子目录映射到容器的目录，代码如下，然后打开127.0.0.1:9384，看到Hello World。（IP写成127.0.0.1:[四位数字]，否则容易报错）\n\n```bash\n$ mkdir nginx-docker-demo\n$ cd nginx-docker-demo\n$ mkdir html\n$ emacs index.html\n$ <h1>Hello World</h1>\n$ docker run -d -p 127.0.0.1:9384:80 --rm --name mynginx --volume $PWD/html:/usr/share/nginx/html nginx\n```\n\n - 拷贝配置：将容器里的Nginx配置文件复制到本地\n\n```bash\n$ docker container cp mynginx:/etc/nginx .\n```\n\n - 映射配置目录\n```bash\n$ docker run  --rm --name mynginx --volume $PWD/html:/usr/share/nginx/html --volume $PWD/conf.d:/etc/nginx -p 127.0.0.1:4023:80 -d nginx\n```\n\n**3.反向代理**\n\n - 概念\n\n 反向代理方式是指用代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\n\n 例如，用户访问 <http://www.example.com/readme>，但是 <http://www.example.com> 上并不存在 readme 页面，它是偷偷从另外一台服务器上取回来，然后作为自己的内容返回给用户。但是用户并不知情这个过程。对用户来说，就像是直接从 <http://www.example.com> 获取 readme 页面一样。这里的 <http://www.example.com> 这个域名对应的服务器就设置了反向代理功能。\n\n 反向代理服务器，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。如下图所示：\n\n ![反向代理](https://moonbingbing.gitbooks.io/openresty-best-practices/images/proxy.png)\n\n - 应用\n\n 反向代理的典型用途是将防火墙后面的服务器提供给 Internet 用户访问，加强安全防护。反向代理还可以为后端的多台服务器提供负载均衡，或为后端较慢的服务器提供缓 服务。另外，反向代理还可以启用高级 URL 策略和管理技术，从而使处于不同 web 服务器系统的 web 页面同时存在于同一个 URL 空间下。\n\n 本地访问 <http://localhost/deno> 时服务器进行反向代理，从 <https://github.com/ry/deno> 获取页面内容，添加nginx.conf到Nginx配置目录，生效后运行服务器打开 <http://localhost/deno> 会打开 <https://github.com/ry/deno>，代码如下：\n\n```python\nworker_process 1;\n\npid logs/nginx.pid;\nerror_log logs/error.log warn;\n\nevents {\n    worker_connections 3000;\n}\n\nhttp {\n    include mime.types;\n    server_tokens off;\n\n    # 反向代理\n    server {\n        listen 80;\n\n        location / {\n            proxy_pass       https://github.com;\n            proxy_redirect   off;\n            proxy_set_header Host            $host;\n            proxy_set_header X-Real-IP       $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        }\n\n    \tlocation /deno {\n        \tproxy_set_header X-Real-IP       $remote_addr;\n        \tproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        \tproxy_pass       https://github.com/ry/deno;\n    \t}\n    }\n}\n\n```\n\n- 正向代理\n\n 正向代理好比一个跳板，当用户访问不了某网站时，能够访问一个代理服务器，通过连接代理服务器，告诉他需要的访问内容，代理服务器拉取给用户，翻墙工具、游戏代理都是正向代理。\n\n**4.负载均衡**\n\n负载均衡是一种计算机网络技术，用来在多个计算机（计算机集群）、网络连接、CPU、磁盘驱动器或其他资源中分配负载，以达到最佳化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。\n\n使用带有负载均衡的多个服务器组件，取代单一的组件，可以通过冗余提高可靠性。负载均衡服务通常是由专用软体和硬件来完成。\n\n负载均衡最重要的一个应用是利用多台服务器提供单一服务，这种方案有时也称之为服务器农场。通常，负载均衡主要应用于 Web 网站，大型的 Internet Relay Chat 网络，高流量的文件下载网站，NNTP 服务和 DNS 服务。现在负载均衡器也开始支持数据库服务，称之为数据库负载均衡器。\n\n对于互联网服务，负载均衡器通常是一个软体程序，这个程序侦听一个外部端口，互联网用户可以通过这个端口来访问服务，而作为负载均衡器的软体会将用户的请求转发给后台内网服务器，内网服务器将请求的响应返回给负载均衡器，负载均衡器再将响应发送到用户，这样就向互联网用户隐藏了内网结构，阻止了用户直接访问后台（内网）服务器，使得服务器更加安全，可以阻止对核心网络栈和运行在其它端口服务的攻击。\n\n当所有后台服务器出现故障时，有些负载均衡器会提供一些特殊的功能来处理这种情况。例如转发请求到一个备用的负载均衡器、显示一条关于服务中断的消息等。负载均衡器使得 IT 团队可以显著提高容错能力。它可以自动提供大量的容量以处理任何应用程序流量的增加或减少。\n\n在 Nginx 中，HTTP Upstream 模块负责负载均衡，这个模块通过一个简单的调度算法来实现客户端 IP 到后端服务器的负载均衡。在如下的设定中，通过 upstream 指令指定了一个负载均衡器的名称 test.net。这个名称可以任意指定，在后面需要用到的地方直接调用即可。\n\n```c\nupstream test.net{\n    ip_hash;\n    server 192.168.10.13:80;\n    server 192.168.10.14:80  down;\n    server 192.168.10.15:8009  max_fails=3  fail_timeout=20s;\n    server 192.168.10.16:8080;\n}\nserver {\n    location / {\n        proxy_pass  http://test.net;\n    }\n}\n```\n\n**Nginx配置负载均衡**\n\n```c\nupstream webservers {\n    ip_hash;\n    server 192.168.18.201 weight=1 max_fails=2 fail_timeout=2;\n    server 192.168.18.202 weight=1 max_fails=2 fail_timeout=2;\n    server 127.0.0.1:8080 backup;\n}\nserver {\n    listen       80;\n    server_name  localhost;\n    location / {\n        proxy_pass      http://webservers;\n        proxy_set_header  X-Real-IP  $remote_addr;\n    }\n}\n```\n\n - 重新加载配置文件后，访问该地址时发现上述两个IP是交替出现的，达到负载均衡效果\n - 利用max_fails、fail_timeout参数控制异常情况\n - 当所有服务器都停止工作时启动备份服务器\n\n```c\nserver {\n    listen 8080;\n    server_name localhost;\n    root /data/www/errorpage;\n    index index.html;\n}\n\n# cat index.html\n<h1>Sorry......</h1>\n```\n\n - 当算法为ip_hash时，负载均衡调度的状态不能有backup\n\n\n# Supervisor","tags":["lnmp"],"categories":["programing"]},{"title":"iTerm2 常用命令","url":"%2F2018%2F07%2F05%2FiTerm2-kb%2F","content":"1. 自动补全命令： `Cmd-Shift-;`\n\n2. 显示输入历史： `Cmd-Shif-h`\n\n3. 显示所有窗口： `Cmd-Option-e`\n\n4. 新建Tab：`Cmd-T`\n\n5. 切换Tab： `Cmd-左/右`\n","tags":["iTerm2"],"categories":["keyboard"]},{"title":"Git 常用命令","url":"%2F2018%2F07%2F05%2FGit-kb%2F","content":"1. 常规上传步骤\n    1. 建立本地仓库 `git init`\n    2. 添加文件到暂存区： `git add [filename]`\n    3. 暂存区文件提交到本地仓库： `git commit -m 'xxx'` \n    4. 关联本地仓库至GitHub仓库：`git remote add origin [url]`\n    5. 上传本地仓库文件至GitHub远程仓库:  `git push -u origin master` \n    6. 再更改代码上传至远程仓库使用：`git push`\n\n<!-- more -->\n\n2. 分支相关\n    1. 新建并切换到本地分支： `git checkout -b [branch]` （相当于 `git branch [branch]` + `git checkout [branch]`）\n    2. 添加文件： `git add .`\n    3. 提交到本地： `git commit -m 'xxx'`\n    4. 关联并上传至远程仓库分支： `git push --set-upstream origin [branch]`\n    5. 常用命令：\n        - 查看本地所有分支： `git branch -r` \n        - 查看所有分支： `git branch -a`\n        - 查看远程仓库： `git remote`\n        - 删除分枝： `git branch -d [branch]`\n        - 切换远程分支： `git checkout [branch]`\n        - 查看远程仓库的信息： `git remote show [remote]`\n        - 强制上传到远程： `git push -f origin [branch]`\n\n3. 查看本地仓库**状态**： `git status`\n4. 查看已有的**配置**信息： `git config --list`\n5. 设置默认文本编辑器： `git config --global core.editor [name]`\n6. **删除**git本地仓库： `rm -rf .git`\n7. 查询是否使用**代理**： `git config --global http.proxy`\n8. 取消代理： `git config --global --unset http.proxy`\n9. **回滚**最近一次操作： `git reset --soft HEAD^`\n10. **撤销**本地所有**修改**： `git checkout .`\n11. **撤销上一次提交**的所有内容： `git reset HEAD [file-name/为空则为所有文件]`\n12. 查看自己 GitHub 并\b修改账号信息： `curl -i -u username:token https://api.github.com/user` \n","tags":["keyboard"],"categories":["keyboard"]},{"title":"Docker 常用命令","url":"%2F2018%2F07%2F05%2Fdocker-kb%2F","content":"1. 查看所有镜像： `docker image ls`\n\n2. 查看所有镜像（包括ID）： `docker images -a`\n\n3. 删除镜像（通过ID）： `docker rmi [id]`\n\n4. 进入容器： `docker exec -it [container-id] bash`\n\n5. 停止运行容器： `docker stop [container-id]`\n\n6. 查看运行中的容器： `docker ps`\n\n7. 查看所有容器： `docker ps -a`\n\n8. 删除容器： `docker rm [container id]`\n\n9. 查看某容器的信息（IP等）： `docker inspect [container-name]`\n","tags":["Docker"],"categories":["keyboard"]},{"title":"Emacs 快捷键","url":"%2F2018%2F07%2F05%2Femacs-kb%2F","content":"## 文件管理\n\n- 保存文件：`C-x C-s`\n- 退出 emacs：`C-x C-c`\n- 另存为：`C-x C-w`\n- 进入dired： `C-x C-f`\n- 退出dired： `C-g`\n- dired中重命名或移动文件： `R`\n\n<!-- more -->\n\n---\n## 编辑文本\n\n### 删除\n\n- 删除行：`C-a C-k`\n- 下一屏：`C-v`\n- 上一屏：`M-v` \n- 从插入点向回（前面）删除到前面单词的开始处：`M-del` \n- 从插入点向前删除到后面单词的开始处： `M-d`\n\n### 字体\n\n- 首次增加字体大小： `C-x C-+` ，以后 `+`\n- 首次缩小字体： `C-x C- -` ，以后 `-`\n\n### 光标\n- 移动到本行行首： `C-a`\n- 移动到本行行尾： `C-e` \n- 移动到句首： `M-a`，再按移动到上个句首\n\n### 撤销\n\n- 撤销： `C- -` 或 `C- shift加-` 或 `C-/` 或`C-x u`\n\n### 注释\n- 注释选中块：`C-x r t`\n- 反注释选中块：`C-x r k`\n\n---\n## 搜索\n\n- 搜索： `C-s`\n\n---\n## 其他\n\n- 在终端内打开 emacs： `emacs -nw`（通用）\n\n---\n## vim\n\n- 进入输入模式： `i`\n- 进入删除模式： `x`\n- 退出当前模式：`esc`\n- 保存并退出：`:wq`\n- 直接退出： `:q`\n- 强制退出： `:q!`\n","tags":["emacs"],"categories":["keyboard"]},{"title":"Mac 快捷键","url":"%2F2018%2F07%2F05%2FMac-kb%2F","content":"#### 全局\n\n1. 查找 `Cmd-F`\n2. 全屏 `Ctrl-Cmd-F`\n3. 强制退出 `Opt-Cmd-Esc`\n4. 强制Mac重启 `Ctrl-Cmd-电源按钮` （不适用multi-touch bar）\n\n<!-- more -->\n\n#### Safari\n\n1. 使下一标签页成为活跃标签页 `Ctrl-Tab`\n2. 使上一标签页成为活跃标签页 `Ctrl-Shift-Tab`\n\n\n#### 截屏\n\n1. 部分 `Shift-Cmd-4`\n2. 全屏 `Shift-Cmd-3`\n3. 选择区域 `Shift-Cmd-A`\n\n\n#### 文本\n\n1. 粗体／关闭粗体 `Cmd-B` （斜体I、下划线U）\n2. 拷贝样式 `Opt-Cmd-C`\n3. 粘贴样式 `Opt-Cmd-V`\n4. 粘贴并匹配样式 `Opt-Shift-Cmd-V`\n5. 存储为 `Shift-Cmd-S`\n6. 选中行 `Shift-Cmd-左（行尾）／右（行首）`\n7. 光标向前/后跳一个词 `Opt - 左/右`\n\n#### Finder\n\n1. 打开“电脑”窗口 `Shift-Cmd-C`\n2. 打开“前往文件夹”窗口 `Shift-Cmd-G`\n3. 隐藏或显示Finder窗口中的路径栏 `Opt-Cmd-P`\n4. 打开所选项 `Cmd-下箭头`\n\n#### 设置\n\n1. 开启安全性与隐私中安装来自任何来源的软件： `sudo spctl --master-disable`\n2. 在finder内显示所有隐藏文件和文件夹： `defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder` （隐藏时设为false）\n","tags":["Mac"],"categories":["keyboard"]},{"title":"Pro Git - notes","url":"%2F2018%2F06%2F10%2Fpro%20git%2F","content":"# 一、Git 起步\n\n## 1. 版本控制\n\n版本控制是记录若干文件内容变化，以便于将来查阅特定版本修订情况的系统。不仅限于软件代码文本，任何类型的文件都可以进行版本控制，比如图片或页面布局文件。\n\n版本控制系统分为三类：\n<!-- more -->\n- 第一类为本地版本控制，最流行的是rcs系统，至今仍在使用。工作原理是保存并管理文件补丁（记录修订前后内容变化的特定格式的文本文件），rcs根据修订的补丁计算各个版本的文件内容。\n- 集中化的版本控制（CVCS）。使用不同系统进行协同工作的开发者通过客户端连接到cvcs的集中管理服务器，取文件或提交更新。\n- 分布式版本控制系统（DVCS）。客户端可将原始代码仓库镜像下载，如服务器发生故障可通过本地仓库恢复。每次的提取相当于对代码仓库的完整备份，并且增加不同远端仓库的交互功能。\n\n## 2. Git 特点\n\n- 关注文件数据的整体变化，而不限于文件内容差异。\n- 几乎所有操作都可以本地执行\n- 时刻保持数据完整性（校验、计算、标识）\n- 大部分操作在添加数据\n\n## 3. Git 工作流程\n\nGit内部的文件存在三种状态：committed（已修改）、modified（已提交）、staged（已暂存）。已提交表示该文件已保存在本地数据库；已修改表示修改了某文件，但未提交保存（从暂存区到仓库）；已暂存表示把已修改的文件放在下次提交时要保存的清单中。\n\n工作流程：\n\n- 在工作目录中修改文件\n- 对修改文件做快照，并保存到暂存区\n- 提交更新，将暂存区的文件快照转存到 git 目录\n\n## 4. Git 配置\n\n- 用户信息\n\n   当前用户主目录下的用户配置：\n \n   ```bash\n   $ git config --global user.name '[your-name]'\n   $ git config --global user.email [your-email]\n   ```\n\n  如想在特定项目中使用其他名字或邮箱，配置时去掉 --global 即可。\n\n- 设置默认编辑器 `git config --global core.editor [editor]`\n\n- 设置差异分析工具，`git config --global merge.tool [tool-name]`。\n\n  常见设置工具有kdiff3、tkdiff、meld、xxdiff、emerge、vimdiff、gvimdiff、ecmerge、opendiff等\n\n- 查看配置信息为 `git config --list`。\n  \n\t查看指定环境变量的设定：`git config [variable-name]`。\n  \n---\n\n# 二、Git 基础\n\n\n## 1. 取得 Git 仓库\n\n- 从当前目录初始化\n\n  进入当前目录，执行 `git init` , 如果当前目录下有几个文件想要纳入版本控制, 需要先告诉 Git 开始跟踪：\n\n  ```bash\n  $ git add [file-name]\n  $ git commit -m 'initial project version'\n  ```\n\n- 从现有仓库克隆\n\n  ```bash\n  $ git clone [url]\n  ```\n\n  该命令会在当前目录下创建一个同名目录并拉取所有数据，取出最新版本。如需自定义项目目录名称：\n\n  ```bash\n  $ git clone [url] [folder-name]\n  ```\n\n\n## 2. 记录每次更新\n\n首先明确：工作目录下的所有文件只有两种状态：已跟踪或未跟踪。\n \n已跟踪的文件状态可能有如下几种：未更新、已修改、放入暂存区。未跟踪文件没有任何记录。\n\n- 查看文件状态使用命令 `git status`， 如果原文件夹内没有其他文件，会显示\n\n  ```bash\n  On branch master\n  nothing to commit (working directory clean)\n  ```\n\n  如存在其他文件则提示\n\n  ```bash\n  On branch master\n  Untracked files:\n    (use \"git add <file>...\" to include in what will be committed)\n\n    jsconfig.json\n    \n  nothing added to commit but untracked files present (use \"git add\" to track)\n  ```\n\n- 跟踪新文件README\n\n  ```bash\n  $ git add README\n  ```\n\n  再查看文件状态时提示README已跟踪并暂存：\n\n  ```bash\n  On branch master\n  Changes to be committed:\n    (use \"git reset HEAD <file>...\" to unstage)\n\n    new file:   README\n  ```\n\n- 暂存已修改文件\n\n   当修改之前处于已跟踪状态的文件homePage.js后，再查看文件状态会提示：\n\n  ```bash\n  On branch master\n  Changes to be committed:\n    (use \"git reset HEAD <file>...\" to unstage)\n\n    new file:   README\n\n  Changes not staged for commit:\n    (use \"git add <file>...\" to update what will be committed)\n    (use \"git checkout -- <file>...\" to discard changes in working # directory)\n\n    modified:   assets/Script/homePage.js\n  ```\n\n  homePage.js 的内容变化但未放入暂存区，此时运行 `git add ` 更新内容，或运行 `git checkout` 无视变化。\n\n  ```bash\n  $ git add homePage.js\n  $ git status\n  On branch master\n  Changes to be committed:\n    (use \"git reset HEAD <file>...\" to unstage)\n   \n    new file:   README\n    modified:   assets/Script/homePage.js\n  ```\n\n  这时如果修改homePage.js，\b再运行 `git status`，发现出现了两个版本的homePage.js：\n\n  ```bash\n  On branch master\n  Changes to be committed:\n    (use \"git reset HEAD <file>...\" to unstage)\n   \n    new file:   README\n    modified:   assets/Script/homePage.js\n   \n  Changes not staged for commit:\n    (use \"git add <file>...\" to update what will be committed)\n    (use \"git checkout -- <file>...\" to discard changes in working # directory)\n   \n    modified:   assets/Script/homePage.js\n  ```\n\n  如果这时提交，提交的实际上是修改前的版本，暂存区暂存的是最初执行 `git add` 时的版本，所以此处需要**重新执行一次 `git add` 存储最新版**。\n\n  ```bash\n  $ git add assets/Script/homePage.js\n  $ git status\n  On branch master\n  Changes to be committed:\n    (use \"git reset HEAD <file>...\" to unstage)\n   \n    new file:   README\n    modified:   assets/Script/homePage.js\n  ```\n\n- 忽略文件\n\n  有些文件无需纳入版本管理，也不希望出现再未跟踪文件列表，可以将这些文件添加到 .gitignore 中。\n\n  文件 .gitignore 的格式规范如下：\n \n  - 所有空行或以 # 开头的\b行（注释）都会被Git忽略\n  - 可以使用标准 glob 模式（shell 使用的简化正则表达式）匹配\n  - 如要忽略目录则在后面添加\b反斜杠 /\n  - 反向忽略可在模式前加惊叹号 ! 取反\n\n  那么我们现在添加 .gitignore 文件，内容如下：\n\n  ```\n  *.json           # 忽略整个目录下所有以 .json 结尾的文件\n  !jsconfig.json   # 但jsconfig.json除外\n  /local           # 忽略主目录下的local文件（或文件夹）\n  library/         # 忽略library文件夹\n  assets/*.meta    # 忽略assets\b直属子目录下的所有 .meta 文件 \n  ```\n\n  此时再查看代码状态为：\n\n  ```bash\n  On branch master\n  Changes to be committed:\n    (use \"git reset HEAD <file>...\" to unstage)\n   \n    new file:   README\n    modified:   assets/Script/homePage.js\n   \n  Untracked files:\n    (use \"git add <file>...\" to include in what will be committed)\n   \n    .gitignore\n    creator.d.ts\n    jsconfig.json\n    myKingClient/\n    temp/\n  ```\n\n- 查看已暂存和未暂存的更新\n\n   `git status` 命令列出修改过的文件，但如过想查看具体的修改内容，使用 `git diff` 命令，可以查看已暂存和未暂存的更新。\n\n  此时修改 Refresh.js 文件，不进行暂存，查看状态如下：\n\n  ```bash\n  On branch master\n  Changes not staged for commit:\n    (use \"git add <file>...\" to update what will be committed)\n    (use \"git checkout -- <file>...\" to discard changes in working # directory)\n   \n      modified:   assets/Script/Refresh.ts\n  ```\n\n  查看**未暂存文件**的更新，执行 `git diff`（如果更新后全部暂存则再使用这条命令看不到文件改动）。\n \n  查看**已暂存**的文件与之前快照的差异，使用 `git diff --cached` 或 `git diff --staged`。\n\n  此时先暂存 Refresh.js 再进行编辑，运行 `git status` 会看到两个版本：\n\n  ```bash\n  $ git st\n  On branch master\n  Changes to be committed:\n    (use \"git reset HEAD <file>...\" to unstage)\n\n    modified:   assets/Script/Refresh.ts\n\n  Changes not staged for commit:\n    (use \"git add <file>...\" to update what will be committed)\n    (use \"git checkout -- <file>...\" to discard changes in working # directory)\n\n    modified:   assets/Script/Refresh.ts\n  ```\n\n- 提交更新\n\n  现在把 Refresh.js 提交到暂存区，先用 `git status` 查看是否正确再进行提交，即执行 `git commit`, 会启动编辑器编辑提交说明，显示如下信息：\n\n  ```bash\n  Please enter the commit message for your changes. Lines starting with '#' will be ignored, and an empty message aborts the commit.\n  \n  On branch master\n  Changes to be committed:\n    new file:   README\n    modified:   assets/Script/Refresh.ts\n  ```\n\n  默认信息中包括运行 `git status` 的输出，也可以使用 `git commit -v` 可将所有变化显示到默认信息中。\n\n  退出编辑器时Git会提交你添加的说明和更新，忽略注释。\n\n  ```bash\n  [master 4a19a17] first commit for test\n  3 files changed, 10 insertions(+), 20 deletions(-)\n  create mode 100644 README\n  ```\n\n  使用 `git commit -m [commit]` 可以不通过编辑器直接提交说明。\n\n  提交后显示提交的分支，SHA-1 校验和内容，改动的文件\b个数和添加、删除的行数。\n\n- 跳过暂存区\n\n  为简化流程，Git提供跳过暂存区的方式，\b提交时自动将所有已跟踪的文件暂存一并提交，即在命令中添加 `-a`， 可简化命令为 `git commit -am 'an easy way'`\n\n- 移除文件\n\n  - 从暂存区中移除文件，可使用 `git rm` 完成，**执行后会一同删除工作目录中的文件**。\n\n  - 如果只是在工作目录中删除（\b执行 `rm`），\b查看状态时会在未暂存中看到：\n\n    ```bash\n    $ rm jsconfig.json\n    On branch master\n    Changes not staged for commit:\n      (use \"git add/rm <file>...\" to update what will be committed)\n      (use \"git checkout -- <file>...\" to discard changes in working # directory)\n     \n      deleted:    jsconfig.json\n    ```\n\n    接着再运行 `git rm`\b，显示删除暂存区内的 jsconfig.json：\n\n    ```bash \n    $ git rm jsconfig.json\n    On branch master\n    Changes to be committed:\n      (use \"git reset HEAD <file>...\" to unstage)\n    \n      deleted:    jsconfig.json\n    ```\n\n    如需删除之前修改过且放入暂存区的文件，必须使用强制删除\b `-f`，防止误删文件。\n\n  - 只删除\b Git 仓库中的文件，保留工作目录中的文件，即只从跟踪清单中删除，使用 `git rm --cached [file-name]`。\n\n    \b可以列出文件或文件夹的\b名字，或者glob模式（使用 * 时需要在其前面加反斜杠 \\，否则不会递归匹配）\n\n- 移动文件的命令为 `git mv [file-from] [file-to]`，其中[file-to] 可以传递新文件名或目录。\n\n## 3. 查看提交历史\n\n使用 `git log` 不设置参数时，默认按提交时间列出更新，最近的在最上面，包括 SHA-1 校验、作者名称、作者的邮箱、提交时间和提交说明\n\n```bash\n$ git log\ncommit 05f64a0746978bcba0219a04196545052ccb4f1d\nAuthor: shifei <wenjzhuo@icloud.com>\nDate:   Mon Jun 11 00:17:53 2018 +0800\n\n    initial project version\n```\n   \n`git log` 常见使用如下：\n\n```bash\n$ git log -p  # 显示每次提交的内容差异\n$ git log -p -2  # 显示\b最近两次的提交的内容差异\n$ git log --stat  # 显示每次更新的简要信息，如改动文件、增减行数\n$ git log --pretty=[oneline/short/full/fuller]  # 通过几种不同方式显示每次改动\n$ git log --pretty=format:'%h - %an, %ar : %s'  # 定制显示格式\n```\n\n`git log` 支持的参数\n\n| 选项 | 说明 |\n| --- | --- |\n| -p |  按补丁格式显示每个更新之间的差异 |\n| --shortstat      |   只显示 --stat中最后的行数及增删统计   |\n| --name-only      |   仅再提交信息后显示已修改的文件清单   |\n| --abbrev-date      |   使用较短的相对时间显示   |\n| --graph      |   显示 ASCII 图形表示的分支\b合并历史   |\n| --pretty      |   使用其他格式显示历史提交信息   |\n\n其中 format 的参数：\n\n| 选项 | 说明 |  \n| --- | --- |\n| %H | 提交对象的完整哈希值 |\n| %h |   提交对象的简短哈希值   |\n| %T | 树对象的完整哈希值 |\n| %t |   树对象的简短哈希值   |\n| %P | 父对象的简短哈希值 |\n| %p |   扶对象的简短哈希值   |\n| %an | 作者名字 |\n| %ae |   作者电子邮件地址   |\n| %ad | 作者修订日期 |\n| %ar |   作者修订日期，按多久以前的方式显示   |\n| %cn | 提交者名字 |\n| %ce |   提交者电子邮件   |\n| %cd | 提交日期 |\n| %cr |   提交日期，按多久以前的方式显示   |\n| %s |   提交说明   |\n\n- 限制输出长度\n\n| 选项        | 说明   |  \n| --------   | ----- |\n| -n     | 仅显示最近的 n 条提交 |\n| --since, --after    |   仅显示指定时间之后的提交   |\n| --until, --before   | 仅显示指定时间之前的提交 |\n| --author        |   仅显示指定作者相关的提交   |\n| --committer     | 仅显示指定提交者的提交 |\n\n- 显示最近的n条改动：`git log -n`\n\n- 按操作时间限制：`git log --since=1.year`，可以使用量词为单位，也可以使用诸如 “2013-02-21” 的写法。\n\n- 使用图形化工具gitk查阅历史\n\n## 4. 撤销操作\n\n- 修改最后一次*提交*\n\n  执行 `git commit --amend` 命令可重新提交暂存区快照，如\b无需改动直接保存退出即可；如需改动，修改后提交即可覆盖之前的提交说明。\n\n  ```bash\n  $ git commit -m 'initial commit'\n  $ git add [file]\n  $ git commit --amend\n  [master 16328cb] check: test amend commit in an easy way\n  Date: Mon Jun 11 08:47:14 2018 +0800\n  3 files changed, 20635 insertions(+), 273 deletions(-)\n  delete mode 100644 assets/Script/Refresh.ts\n  create mode 100644 creator.d.ts\n  rename assets/Script/homePage.js => temp.js (100%)\n  ```\n\n- 取消已暂存*文件*\n\n  添加完文件后发现有多余文件，通过 `git reset HEAD <file>` 实现移除即可，\b然后\b利用 `git status` 可查看文件状态，这时\b该文件处于已修改未暂存的状态。\n\n- 取消对文件的*修改*\n\n  当修改某文件后想回退到修改之前的版本，此时先运行 `git status` 显示：\n\n  ```bash\n  $ emacs .gitignore\n  $ git st\n  On branch master\n  Changes not staged for commit:\n    (use \"git add <file>...\" to update what will be committed)\n    (use \"git checkout -- <file>...\" to discard changes # in working directory)\n  \n    modified:   .gitignore\n  \n  $ git checkout -- .gitignore\n  On branch master\n  Changes to be committed:\n    (use \"git reset HEAD <file>...\" to unstage)\n  \n    new file:   .gitignore\n  ```\n\n  此时再查看文件内容已经回到之前的版本，所有修改全部丢失。\n  如果只需回退版本同时保留\b修改内容，可用 stashing 和分支处理。\n\n  **所有提交到Git的数据都可以被恢复。**\n\n## 5. 远程仓库\n\n- 查看当前配置的远程仓库\n\n  使用 `git remote` 可查看当前目录配置的远程仓库，Git默认生成名字为 origin 的原始仓库。\n  \n  使用 `git remote -v` 显示仓库名称和地址，如有多个远程仓库也能全部列出。\n\n- 添加远程仓库\n\n  通过 `git remote add [name] [url]` 添加远程仓库，[name] 可以随意命名，而且是一个仓库的名字，不是分支。\n\n- 抓取数据\n\n  关联远程仓库后，通过 `git fetch [remote-name]` 即可抓取分支上有的、本地没有的数据。\n\n  **fetch 执行之后\b本地才能访问到这个分支，进行所有后续操作。\b只关联不抓取没有用。**\n\n  fetch 命令只将远端数据拉到本地，不会自动合并，需要手动合并。\n  \n  在跟踪远端仓库的分支后，使用 `git pull` 命令可以自动抓取数据并自动合并到本地仓库的当前分支。\n\n- 推送数据至远程仓库\n\n  通过命令 `git push [remote-name] [branch-name]` 实现。\n\n- 查看远程仓库信息\n\n  通过 `git remote show [remote-name]` 查看某个远程仓库的信息，显示在当前目录中运行 `git fetch` 和 `git push` 时自动执行的分支、远端分支中已跟踪和未跟踪的分支、运行 `git push` 时缺省推送的分支。\n  \n- 远程仓库的删除和重命名\n\n  通过 `git remote rename [name] [new-name]` 进行重命名，通过 `git remote rm [branch-name]` 进行\b远端仓库删除。\n\n## 6. 打标签\n\n- 查看已有标签，运行 `git tag`\n\n- 新建标签\n\n  分为两类：轻量级的和含附注的。\n  创建一个含附注的标签，使用 `git tag -a [version] -m [commit]` 指定标签名：\n\n  ```bash\n  $ git tag -a v1.2 -m 'version 1.2' \n  $ git tag\n  v1.2\n  ```\n\n  执行 `git tag -a v12`，默认编辑器添加commit。再执行 `git show [version]` 查看相应标签的版本信息，并连同显示打标签的提交对象。\n\n- 签署标签\n\n  使用GPG签署标签，需要有自己的私钥:`git tag -s v0.9 -m 'signed 0.9` 。\n\n- 轻量级标签\n\n  轻量级标签实际上是保存着对应提交对象的校验核信息的文件，命令不带参数：\n\n  ```bash\n  $ git tag v1.1\n  $ git tag\n  v1.1\n  v12\n  ```\n\n- 验证标签\n\n  `git tag -v [tag-name]` 可验证签署的标签，需要有签署者的公钥，存放在keyring中。\n\n- 后期加注标签\n\n  可以对原来的提交加注标签，通过 `git tag -a [version] [SHA-1]` 实现：\n\n  ```bash\n  $ git log --pretty=oneline\n  # 05f64a0746978bcba0219a04196545052ccb4f1d initial # project version\n  $ git tag -a v4d 05f6\n  $ git tag\n  v1.1\n  v4d\n  ```\n\n- 分享标签\n\n  默认情况下，`git push` 不会推送标签到远端，必须添加显式命令分享标签，运行 `git push origin [tagname]` 即可，如一次性推送所有标签，使用 `git push origin --tags`。\n\n## 7. 技巧\n\n- 自动完成\n\n  在 Git 的源码中提供自动完成的脚本，可以复制到用户主目录中\n\n- Git 命令别名：`git config --global alias.[alias] [original name]`。\n\n  使用下述写法相当于创建新命令，如取消暂存文件：\n\n  ```bash\n  $ git config --global alias.unstage 'reset HEAD --'\n  ```\n\n  如查看最后一次的提交信息：\n\n  ```bash\n  $ git config --global alias.last 'log -1 HEAD'\n  ```\n---\n\n# 三、Git 分支\n\n\n## 1. 理解分支\n\nGit 中的分支本质上是个**指向 commit 对象的可变指针**。Git 使用 master 作为分支的默认名字，在多次提交后，指向最后一次提交对象的 master \b分支在每次提交时自动向前移动。\n\nGit 创建新的分支时即创建一个新的分支指针。\n\n*Git 内保存一个名为 HEAD 的特别指针，指向工作中的本地分支。*\n\nGit 中的分支仅是一个包含所指对象*校验和*（SHA-1）的文件，所以非常容易创建和销毁，而且迅速；提交时记录 parent 对象，所以易于合并。\n\n## 2. 基本的分支与合并\n\n在实际工作中，很多时候会创建多个分支并行开发。当切换分支时，Git 会将工作目录的内容恢复为检出某分支时它所指向的那个 commit 的快照，自动添加、删除或修改文件以确保内容与上次提交时一致。\n\n如果顺着一个分支走下去可以到达另一个分支，那么 Git 在合并时只会简单地把指针前移（无需解决分歧），即快进 Fast-forward。\n\n但如果\b不同分支内修改了相同文件，Git 在自动合并时产生冲突，无法自动合并，这时合并不只是移动指针，Git 分别从各自分支的末端和他们的共同祖先进行了三方合并计算，将结果创建新快照，提交到新的特殊的commit，即 merge commit，在合并过程中 Git 自己判断哪个分支是最佳合并基础，不需要手动指定。当我们修改冲突文件后，依次上传即可。\n\n## 3. 分支管理\n\n通过 `git branch` 可以查看分支列表，`git branch -v` 能查看分支列表以及它们各自最后一次 commit 信息，`git branch --merged` 可以查看哪些分支已被合并、`git branch --no-merged` 可查看尚未被合并的分支。\n\n## 4. 分支式工作流程\n\n保留master分支上的稳定版本，使用其他平行分支进行测试开发，所以稳定分支经常比较老旧。在大型或复杂的项目中，这种工作方式有利于维护不同层次的稳定性。\n\n## 5. 远程分支\n\n远程分支是对远程仓库状态的索引。\n\n特点：无法移动；只有在进行 Git 的网络活动时会更新。\n\n表示形式： 远程仓库名／分支名\n\n- 5.1 推送\n\n\b`git push origin [branch]` \n\n（默认把远程分支命名与本地分支相同）\n完整版命令： `git push origin [local-branch]:[remote-branch]`\n\n- 5.2 跟踪分支\n\n从远程分支检出的本地分支称为跟踪分支。\n\n通过 `git checkout --track origin/[branch]` 在已有的本地分支内跟踪远程分支，`git checkout -b [branch] origin/[branch]` 创建并切换到新的本地分支，并且将远程分支里的内容合并到该分支内。跟踪分支是与远程分支有直接联系的本地分支，在跟踪分支内使用 `git push` 时 Git 自行推断推送到哪个远程分支、使用 `git pull` 会获取所有远程索引并把数据合并到本地分支。\n\n- 5.3 删除远程分支\n\n`git push origin :[branch]`\n\n原理：使用 `git push [remote-name] [local-branch]:[remote-branch]` 时本地分支为空白\n\n## 6 衍合\n\n整合分支的方法有两种： merge（合并）和 rebase（衍合）。\n\n- merge：把两个分支最新的快照（C3、C4）以及二者最新的共同祖先（C2）进行三方合并，如下图：\n![merge](http://test.imgurl.org/temp/1807/71c0d50ca56302b9.png)\n\n- rebase: 把C3里产生变化的补丁重新在C4的基础上打一遍。原理是回到两个分支的共同祖先，提取每次提交时产生的差异，把这些差异分别保存到临时文件\b内，然后从当前分支转换到需要衍合的分支，依序使用每一个差异补丁文件。\n\n![rebase](http://test.imgurl.org/temp/1807/e844a07079f0797b.png)\n\n上图所示及将 C3 产生的\b改变衍合到 C4，然后再切换到 master 进行快进合并即可，此时的 C3‘ 与上述方法的 C5 相同，代码如下：\n\n```bash\n$ git checkout experiment\n$ git rebase master\n$ git checkout master\n$ git merge experiment\n```\n\n**永远不要衍合已经推送到公共仓库的更新。**在衍合的过程中实际上抛弃了现存的 commit 并且创造了一些类似但不同于之前的新的 commit。如果他人下载某分支\b并在此基础上工作，该分支的上传者利用 `git rebase` 重写了 commit，那么其他人就必须重新合并（相同的日期与提交说明，不同的 SHA-1 校验值）。\n\n---\n\n# 四、服务器上的 Git\n\n任何人都可以访问的共享仓库，可以推送和拉取数据，那么这个仓库可称为“**git 服务器**”。\n\n## 1. 协议\n\nGit 可以使用四种主要的协议来传输数据： 本地传输、SSH 协议、Git 协议和 HTTP 协议。\n\n除 HTTP 协议外，其他协议均要求在服务器端安装并运行 Git。\n\n### 1.1 本地协议\n\n本地协议是最基础的协议，远程仓库在本地协议中就是硬盘上的另一个目录。用于团队中每个成员都对一个共享的文件系统（如 NFS）拥有访问权，或多人公用同一台电脑（较少）。\n\n命令如 `git clone /opt/git/.git` 或 `git clone file:///opt/git/.git`。\n\n优点在于简单，并同时保留了现存文件的权限和网络访问权限。缺点在于不能从不同位置访问此共享权限。如想在家里访问，需要先挂载远程硬盘，比基于网络连接的访问速度更慢；缺点之二在于该方法不一定最快，本地仓库只在数据访问速度快时才快，如果在同一个服务器上，都\b允许 Git 访问本地硬盘，通过 NFS 访问仓库通常比 SSH 更慢。\n\n### 1.2 SSH 协议\n\nSSH 协议是 Git 传输协议中最常见的协议，也是唯一一个同时便于读和写的网络协议（HTTP 和 Git 通常是只读的），而且可以验证授权。\n\n`git clone ssh://user@server:project.git`，不指明协议时 Git 默认使用 SSH：`git clone user@server:project.git`不指明用户时 Git 默认使用当前登陆的用户：`git clone server:project.git`\n\n- 优点：拥有对网络仓库的写的权限；SSH 架设相对简单；SSH 安全性高；SSH 在传输前尽可能压缩数据（高效）。\n- 缺点：不能实现仓库的匿名访问（不利于开源项目）。\n\n### 1.3 Git 协议\n\n包含在 Git 软件包中的特殊守护进程，\b监听一个提供类似于 SSH 服务的特定端口（9418）而无需任何授权。Git 协议是现存最快的传输协议，缺点就是缺少授权机制。\n\n### 1.4 HTTP/S 协议\n\n该协议架设简便，将 Git 的纯仓库文件放在 HTTP 的文件根目录下，配置一个特定的 post-update 钩挂即可。\bHTTP 协议的弊端在于客户端的效率更低。\n\n## 2. 在服务端部署 Git\n\b略\b\n\n## 3. \b生成 SSH 公钥\n\n首先确认是否已有公钥，SSH 公钥默认存储在账户的 ~/.ssh 目录，查看该目录下是否有‘文件名’和‘文件名.pub’来命名的一对文件。‘文件名’通常是 id_dsa 或 id_rsa，.pub 是公钥，另一个是秘钥。如不存在这些文件或目录，可用如下命令生成：\n\n`ssh-keygen`\n\n## 4. 架设服务器\n\n将公钥添加至服务器。\n\n## 5. 公共访问\n\n运行一个静态 web 服务，将其跟目录设为 Git 仓库所在的位置，开启 post-update 挂钩，即可实现匿名读取权限。\n\n## 6. 网页界面 GitWeb\n\nGit 自带一个叫做 GitWeb 的 CGI 脚本，可以架设一个简单的网页界面使其可视化\n\n## 7. 权限管理器 Gitosis\n略\n## 8. Git 进程\n略\n\n## 9. Git 托管服务\n\n支持 Git 托管的站点如下图示：\n\n![git](http://test.imgurl.org/temp/1807/9680ba9a15042327.png)\n\n---\n\n# 五、分布式 Git\n\n## 1.分布式工作流程\n\n### 1.1 集中式工作流\n\n通常集中式工作流使用单点操作模型，存放代码仓库的中心服务器可以接受所有开发者提交的代码，所有开发者都是普通节点。\n\n如果有两个开发者同时克隆并进行开发，修改不同内容，只有在\b第一个开发者推送到服务器后、第二个开发者必须先合并第一个开发者修改后的数据后才能推送到共享服务器。\n\n### 1.2 集成管理员工作流\n\n开发者们从官方的项目仓库克隆到自己的公共仓库，修改后将自己的提交推送，由官方仓库的维护者拉取并合并到主项目。维护者在自己的本地也有克隆仓库，可以将开发者的公共仓库作为远程仓库添加进来，经过测试无误后合并到主干分支，再推送到官方仓库。GitHub 上使用得最多的就是这种工作流，fork 某个项目到自己的列表，称为自己的公共仓库，然后将更新提交到这个仓库，便于开发者和维护者各自进行工作。\n\n### 1.3 司令官与副官工作流\n\n一般用于超大型的项目，比如 Linux 内核项目。各个集成管理员分别负责集成项目中的特定部分（即副官），所有这些集成管理员头上还有一个负责统筹的总集成管理员（司令官），司令官维护的仓库用于提供所有协作者拉取最新集成的项目代码。\n\n![司令官与副官工作流](http://test.imgurl.org/temp/1807/a2bc8531e663275d.png)\n\n## 2. 为项目做贡献\n\n### 2.1 提交指南\n\n- 不要在更新中提交多余的白字符（whitespace）\n- 每次提交时限定于完成一次逻辑功能，如果可能的话分解为多次小更新，以便于理解。\n- 提交说明的撰写规范：提交说明最好限制在一行内；50 个字以下；简明扼要描述更新内容，空一行后再详细\b注解；尽可能详尽注释，包括修订的因由、前后不同实现之间的比较；使用祈使现在式语态，如不要使用 ‘added tests’ 而要使用‘add tests’。来自 tpope.net 的 Tim Pope 提出的模版：\n\n![提交说明的模版](http://test.imgurl.org/temp/1807/904d1fd07b327f09.png)\n\n### 2.2 私有的小型团队\n\n在工作中的一个私有项目，有几位开发者共同开发，源代码不公开，所有开发者都具有推送数据到仓库的权限。\n\n### 2.3 私有团队间协作\n\n更大一点规模的私有团队协作，几个小组分头开发若干特定的功能和集成。利用 Git 分支开发。\n\n### 2.4 \b公开的小型项目\n\n当没有直接更新主仓库分支的权限时，通过一下两种方法将工作成果交给项目\b人维护：第一种是 fork，第二种是通过电子邮件寄送文件补丁。\n\n### 2.5 公开的大型项目\n\n许多大型项目都有自己的接受补丁流程，多数都允许通过开发者邮件列表接受补丁。\n\n## 3. 项目的管理\n\n- 使用特性分支进行工作\n- 采纳来自邮件的补丁\n- 检出远程分支\n- 决断代码取舍\n- 代码继承\n- 给发行版签名\n- 生成内部版本号\n- 准备发布\n- 制作简报\n\n---\n\n# 六、Git 工具\n\n以下这些是 Git 非常强大的功能，可能并不会再日常操作种使用，但某些时候也许会需要。\n\n## 1. 修订版本选择\n\n- 通过使用给出的 SHA-1 值来指明一次提交。Git 可以通过你提供的\b不少于4个的且没有歧义的（只有一个对象以这段 SHA-1 开头）字符来识别你要查看的那次提交。如果出现两个具有相同 SHA-1 值的对象，会得到先前的对象的数据，不过机率非常小。\n\n- 使用分支名称可以指明某次提交。\n\n- `git reflog`: 在引用日志种查看提交记录。\n\n- 通过其祖先来指明某次提交，在 SHA-1 后或 HEAD 后加 ‘^’，可以查看此次提交的副体检。\n\n- 指明一定范围内的提交，如考虑某分支上还有哪些数据未合并到主分支。\n  - 双点：让 Git 区分出可从一个分支种获取而不能从另一个分支种\b获取的\b提交。如下图所示，想要查看 experiment \b上有什么内容没有提交到 master，使用命令 `git log master..experiment`（输出D、C）\n\n  ![双点](http://test.imgurl.org/temp/1807/95f6cf1ed81ab232.png)\n\n  - 多点：在引用前使用 \b‘^’ \b或 ‘--not’ 指明不希望提交被包含在内的分支，如 `git log ^refA refB`\n\n  - 三点：指定被两个引用种的一个包含但又不被两者同时包含的分支。通过 log 命令的常用参数 `--left-right`，如 `git log --left-right master..experiment`\n\n## 2. 交互式暂存\n\nGit 中提供了很多脚本来辅助某些命令行\b任务，方便开发者构建\b只包含特定组合和部分文件的提交。\n\n如在运行 `git add` 时加上 ‘-i’或 ‘--interactive’，Git 进入到交互式的 shell 模式：\n```\n$ git add -i\n           staged     unstaged path\n  1:        +1/-0      nothing aj.js\n\n*** Commands ***\n  1: status\t  2: update\t  3: revert\t  4: add untracked\n  5: patch\t  6: diff\t  7: quit\t  8: help\nWhat now> 1\n           staged     unstaged path\n  1:        +1/-0      nothing aj.js\n\n*** Commands ***\n  1: status\t  2: update\t  3: revert\t  4: add untracked\n  5: patch\t  6: diff\t  7: quit\t  8: help\nWhat now> \n```\n\n## 3. 储藏\n\n当在进行项目种某部分的工作，里面的东西处于杂乱的状态，如果想转到其他分支上进行其他工作时，并不想提交现在的进行到一半的工作，否则以后无法\b回到这个工作点，这时可以使用 `git stash` 进行储藏。\n\n储藏可以获取工作目录中的中间状态，并将其保存到一个未完结变更的\b堆栈中，随时可以调用。\n\n`git stash list` 可以查看现有的储藏，`git stash apply` 会默认使用最近的储藏并尝试应用，如果想指定某个储藏： `git stash apply stash@2`（从0开始）。\n\n`git stash branch [branch]` 创建一个新的分支，重新应用，成功后丢弃储藏。\n\n## 4. 重写历史\n\n### 4.1 改变最近一次提交\n\n改变提交说明，或改变\b杠杠通过增加、改变、删除而记录的快照。\n\n修改最近一次提交说明：`git commit --amend`\n\n### 4.2 修改多个提交说明\n\nGit 没有修改历史的工具，但可以使用 rebase 工具来衍合一系列的提交到它们原来所在的 HEAD 上而不是移到新的上面。\n\n使用 `git rebase -i`，再\b指明想要\b衍合的提交，如 `git rebase -i HEAD^3`，即修改第三次提交的副提交（四次提交）\n\n## 5. 使用 Git 调试\n\n### 5.1 文件标注\n\n文件标注可以追踪某段代码到底是何时引入的，通过 `git blame` 来标注文件，参数 `-L` 可限制\b\b输出范围，`-C` 会分析标注的文件，如果时从其他地方拷贝来的文件则会尝试找出其中代码片段的原始出处。\n\n### 5.2 二分查找\n\n如果不知道问题在哪里发生时，使用二分查找可确认哪次提交引入了错误。\n\n```\n$ git bisect start\n$ git bisect bad\n$ git bisect good [commit-tag]\n# 告诉 bisect 已知的最后一次\b的正常\b提交\n```\n\n然后 Git 查询在这次正常提交后到当前的错误版本之间所有的提交，检出其中一个，在测试后如无问题则 `git bisect good`，Git 继续提供下一个直到发现错误的提交时 `git bisect bad`，修复错误后运行 `git bisect reset` 重设 HEAD 到开始的地方。\n\n## 6. 子模块\n\n现实情况中，当你在一个项目上工作时，需要使用另外一个项目，可能时一个第三方库或是独立开发的库。Git 子模块允许将一个 Git 仓库当作另外一个 Git 仓库的子目录，\b允许克隆另外一个仓库到项目中并保持你的提交相对独立。\n\n- 通过 `git submodule add` 将外部项目添加为子模块，会新增 ‘.gitmodules’ 文件。\n\n- 克隆一个带有子模块的项目，在执行 `git clone` 后要\b运行 `git submodule init` 来初始化本地配置文件，`git submodule update` 来拉取所有数据并检出上层项目内所列出的合适的提交，此后的每次拉取都需要运行 `git submodule update`\n\n- 如果工作中要按照分组获取一个大项目的子目录的子集，只要将每一个子目录都做成独立的 Git 仓库，然后创建一个上层项目的 Git 仓库包含多个子模块。这个方法的优势在于可以在上层项目中通过标签和分支更为明确地定义项目之间的关系。\n\n## 7. 子树合并\n\n当 Git 归并时，它会检查需要归并的内容然后选择一个合适的归并策略。如果是两个，Git 使用递归策略；如果\b超过两个，使用章鱼策略。\n\n除此之外也可以选择子树归并。子树归并的思想是当拥有两个工程，将其中一个项目映射到另外一个项目的子目录中，反之亦同。\n\n","tags":["Git"],"categories":["programing"]}]